---
layout: post
title: "spring learn"
date: 2020-07-01
category: Backend
author: zhengjunan
published: true
photoswipe: true
syntaxhighlight: true
---

# 1. Spring

## 1. 简介

- spring 理念：使现有的开发更简便
- ssh: `struct2 + spring + hibernate`
- ssm: `springmvc + spring + mybatis`
- [官网文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)
- [Github](https://github.com/spring-projects/spring-framework)

![spring-web-mvc](https://i.imgur.com/EbIhZg5.png)

```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.9.RELEASE</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.2.9.RELEASE</version>
</dependency>
```

### 1.2 优点

- spring 是一个开源的免费的容器
- spring 是一个轻量级、非入侵式的框架
- 控制反转（IOC），面向切面编程（AOP）
- 支持事务的处理，对框架整合的支持

==Sping 就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架==

### 1.3 组成

![spring-mokuai](https://i.imgur.com/yf9bcCx.png)

### 1.4 拓展

- Spring Boot
  - 一个**快速开发的脚手架**
  - 基于 SpringBoot 可以快速的开发单个微服务
  - 约定大于配置
- Spring Cloud
  - 是基于 Spring Boot 实现的
- `spring + springmvc --> spring boot`
- 弊端：配置太多

## 2. IOC 理论推导

1. `UserDao` 接口

2. `UserDaoImpl` 实现类

3. `UserService` 业务接口

4. `UserServiceImpl` 业务实现类

- 之前程序**主动创建对象**

```java
private UserDao userDao = new UserDaoOracleImpl();
```

- **控制反转 Ioc (Inversion of Control)**
  - 在没有 Ioc 的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制。控制反转后将对象的创建转移给第三方，控制反转就是：获得依赖对象的方式反转了。
  - 使用**set 注入**后，程序不再具有主动性，而是变成被动接受对象
  - 现在不用管理对象的创建，系统的耦合性降低

```java
private UserDao userDao;
// 利用set 进行动态实现值的注入
public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}
```

- **控制反转**是一种通过描述（`xml`或注解）并通过第三方去生产 或获取特定对象的方式。在`spring`中实现控制反转的是 Ioc 容器，其实现方法是依赖注入（`dependency injection，DI`）。
  - **控制**：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用`Spring`后，对象由`Spring`来创建
  - **反转**：程序本身不创建对象，而变成被动的接受对象
  - **依赖注入**：利用`set()`方法来进行注入
- **Ioc：**对象由`Spring`来创建、管理、装配

## 3. Hello Spring

- `hello`对象由`Spring`创建
- `hello`对象的属性由`Spring`容器设置

- 要实现不同的操作，只需要在`xml`配置文件中进行修改

## 4. Ioc 创建对象的方式

1. 默认使用无参构造创建对象

```xml
<bean id="user" class="com.iiwowks.pojo.User">
    <property name="name" value="zhengjunan"/>
</bean>
```

2. 要使用有参构造创建对象时：

   1. 通过下标赋值

   ```xml
   <bean id="user" class="com.iiwowks.pojo.User">
       <constructor-arg index = "0" value="zhengjunanshitutouguai"/>
   </bean>
   ```

   2. 通过参数类型赋值

   ```xml
   <bean id="user" class="com.iiwowks.pojo.User">
       <constructor-arg type="java.lang.String" value="zhengjunanshitutouguai"/>
   </bean>
   ```

   3. 直接通过参数名设置

   ```xml
   <bean id="user" class="com.iiwowks.pojo.User">
       <constructor-arg name="name" value="zhengjunanshitutouguai"/>
   </bean>
   ```

**总结：** 在配置文件加载的时候，容器中管理的对象就已经初始化了。

## 5. Spring 配置

- **Spring** 容器引入

```java
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
```

### 5.1 别名

- 如果添加了别名，就可以通过别名获取这个对象

```xml
<alias name="user" alias="userNew"/>
```

### 5.2 Bean 的配置

- `id` : `bean` 的唯一标识符，相当于对象名

- `class` : `bean` 对象所对应的**全限定名**： 包名 + 类型

- `name` : 别名，可以同时取多个别名

```xml
<bean id="userT" class="com.iiwowks.pojo.UserT" name="userT2, ut2; ut3 ut4">
    <property name="name" value="xxxx"/>
</bean>
```

### 5.3 import

- `import`，一般用于**团队开发**使用，可以将多个配置文件，导入合并为一个

- `applicationContext.xml`

  ```xml
  <import resource="beans.xml"/>
  <import resource="beans2.xml"/>
  <import resource="beans3.xml"/>
  ```

## 6. 依赖注入

- 6.1 构造器注入
- 6.2 **`set`方式注入[重点]**
  - 依赖：bean 对象的创建依赖于容器
  - 注入：bean 对象的所有属性，由容器来注入
- 注入方式：

  - 普通值
  - `Bean`
  - 数组
  - `List`
  - `Set`
  - `Map`
  - `null`
  - `Properties`

- 6.3 拓展方式注入
  - `p`命名空间注入
  - `c`命名空间注入

```xml
<!-- p命名空间注入, 可以直接注入属性的值: property -->
<bean id="user" class="com.iiwowks.pojo.User" p:name="zhangsan" p:age="18"/>

<!-- c命名空间注入, 可以通过构造器注入：construct-args -->
<bean id="user2" class="com.iiwowks.pojo.User" c:name="lisi" c:age="20"/>
```

导入约束才可以使用

```xml
xmlns:p="http://www.springframework.org/schema/p"
xmlns:c="http://www.springframework.org/schema/c"
```

- **`bean`的作用域**

  - **singleton** 单例模式（spring 默认机制）

  ```xml
  <bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
  ```

  - **prototype** 原型模式（每次从容器中 get 的时候，都会产生一个新对象）

  ```xml
  <bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
  ```

  - **request、session、application** 只在 web 开发中使用

## 7. Bean 的自动装配

- Spring 会在上下文中自动寻找，并自动给 Bean 装配属性

在 Spring 中有三种装配的方式：

1. 在 xml 中显示配置
2. 在 java 中显示配置
3. 隐式装配

### 7.1 隐式自动装配 bean【重要】

1.  `byName`：需要保证所有 bean 的 id 唯一，id 与属性值一致
2.  `byType`：需要保证所有 bean 的`class`唯一

```xml
<bean id="cat" class="com.iiwowks.pojo.Cat"/>
<bean id="dog" class="com.iiwowks.pojo.Dog"/>
<bean id="dog2" class="com.iiwowks.pojo.Dog"/>
<!--
autowire="byName": 会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid
autowire="byType": 会自动在容器上下文中查找，和自己对象属性类型相同的bean
-->

<bean id="people" class="com.iiwowks.pojo.People" autowire="byName">
    <property name="name" value="feiwu"/>
</bean>
```

### 7.2 使用注解自动装配

1. 导入约束（context 约束）

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd">

       <context:annotation-config/>

   </beans>
   ```

2. 配置注解的支持

#### @Autowired

- 直接在**属性**上使用，也可以在**set()方法**上使用

- 使用`@Autowired`可以不用编写`set()`方法（前提是这个自动装配的属性在 Spring 容器中存在，类型一致 byType）

- ```java
  // 定义required属性为false, 表示这个属性可以为null，否则不允许为空
  @Autowired(required = false)
  private Cat cat;
  ```

- ```java
  @Autowired
  private Cat cat;
  // @Autowired 默认byType, 之后才用byName
  @Autowired
  @Qualifier(value = "dog2") // value是通过ID实现的，指定一个唯一的bean对象
  private Dog dog;
  ```

#### @Nullable

- 字段标记了这个注解，说明这个字段可以为空

#### @Qualifier

- 配合`@Autowired`使用，指定唯一的一个 Bean 对象注入

- 当有多个同类型对象，id 不同时（自动装配环境比较复杂）

- ```java
  @Autowired
  @Qualifier(value="dog2")
  private Dog dog;
  ```

#### @Resorce

- 这是 java 的注解

```java
@Resource(name = "cat2")
private Cat cat;
@Resource
private Dog dog;
```

- `@Resource` 和 `@Autowired`的区别：
  - 都是用来装配的，都可以放在属性字段上
  - `@Autowired` 优先`byType`方式实现，后`byName`
  - `@Resource` 默认通过`byName`方式实现，先通过`byName`寻找上下文，找不到，就使用`byType`

#### @Component

- @Component 是组件的意思，放在类上，说明这个类被 Spring 管理了，就是一个 Bean

#### @Value

- 直接设置 Bean 的值

## 8. 使用注解开发

使用注解开发， 必须导入 aop 包，导入 context 约束

导入 context 依赖：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 指定要扫描的包，这个包下的注解就会生效-->
    <context:component-scan base-package="com.iiwowks.pojo"/>
    <!-- 开启注解的支持 -->
    <context:annotation-config/>
</beans>
```

1. **bean**

2. **属性如何注入**

   ```java
   // 等价于: <bean id="user" class="com.iiwowks.pojo.User"/>
   @Component
   public class User {
       // 相当于： <property name="name" value="zhangsan"/>
       @Value("zhangsan")
       public String name;
   }
   ```

3. **衍生的注解**

   - `@Component`有几个衍生注解，在 web 开发中，按`mvc`三层架构分层：（作用一样，只是在不同层中使用的注解的名称不一样）
     - `dao` （`@Repository`）
     - `service` （`@Service`）
     - `controller`（`@Controller`）
     - 四个注解功能一样，**都是代表将某个类注册到`Spring`中，装配`Bean`**

4. **自动装配**

   - ` @Autowired`
   - `@Nullable`
   - `@Resource`

5. **作用域**

   - `@Scope`

   - ```java
     // - @Component 注册Bean
     // - @Value     配置值
     // - @Scope     配置作用域
     // 三个注解直接将一个类变成了一个Bean

     // 等价于：<bean id="user" class="com.iiwowks.pojo.User"/>
     // @Component 组件
     @Component
     @Scope("singleton")
     public class User {
         //    public String name = "zhengjunan_显示注入属性";

         // 相当于： <property name="name" value="zhengjunan_@value()"/>
         @Value("zhengjunan_@value()")
         public String name;

         public void setName(String name) {
             this.name = name;
         }
     }
     ```

6. **小结**

   - xml 与注解：

     - xml 更加万能，适用于所有场景，维护简单方便
     - 注解 不是自己的类使用不了，维护相对复杂

   - xml 与注解最佳组合实践

     - xml 用来管理 bean
     - 注解只负责完成属性的注入
     - 让注解生效，必须开启注解的支持

     ```xml
         <!-- 指定要扫描的包，这个包下的注解会生效-->
         <context:component-scan base-package="com.iiwowks"/>
         <context:annotation-config/>
     ```

## 9. 使用 java 的方式配置 Spring

- 完全不使用 Spring 的 xml 配置，全部让 Java 来做，Spring Config 是 Spring 的一个子项目，在 Spring4 之后，成为了 Spring 的核心功能
- `@Configuration`：这是一个配置类
- `@ComponentScan`：包扫描
- `@Import`：导入其它配置类
- `@Bean`：注册 bean

```java
// @Configuration 代表：这个类也会被Spring托管，组册到容器中，他本身也是一个@Component
// @Configuration :代表这是一个 配置类，相当于beans.xml
@Configuration
@ComponentScan("com.iiwowks.pojo")
@Import(MyConfig2.class)
public class MyConfig {
    // 注册一个Bean，相当于一个Bean标签
    // 方法的名字：相当于bean标签中的id
    // 方法的返回值： 相当于bean标签中的class
    @Bean
    public User getUser() {
        // 返回要注入到Bean中的对象
        return new User();
    }
}
```

```java
// 测试类
public class MyTest {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User getUser = context.getBean("getUser", User.class);
        System.out.println(getUser.getName());
    }
}
```

这种纯 Java 的配置方式在 Spring Boot 中随处可见

## 10. 代理模式

- **代理模式的分类：**

  - **静态代理**
    - 抽象角色：使用接口或者抽象类
    - 真实角色：被代理的角色
    - 代理角色：代理真实角色，有些附属操作
    - 客户：访问代理角色的人
  - 代码步骤:

    1. 接口

    ```java
    // 租房 租房接口，
    public interface Rent {
        public void rent();
    }
    ```

    2. 真实角色

    ```java
    public class Host implements Rent{
        @Override
        public void rent() {
            System.out.println("房东要出租房子了！");
        }
    }
    ```

    3. 代理角色

    ```java
    public class Proxy implements Rent{
        private Host host;

        public Proxy(){
        }

        public Proxy(Host host) {
            this.host = host;
        }

        @Override
        public void rent() {
            host.rent();
            hetong();
            fare();
        }

        // 看房
        public void seeHouse() {
            System.out.println("中介带你看房！");
        }

        // 收中介费
        public void fare() {
            System.out.println("收中介费！");
        }

        // 签合同
        public void hetong() {
            System.out.println("签合同！");
        }
    }
    ```

    4. 客户端访问代理角色

    ```java
    public class Client {
        public static void main(String[] args) {

            Host host = new Host();
            // 代理：中介帮房东租房子，同时中介会有一些特殊操作
            Proxy proxy = new Proxy(host);
            // 不用面向房东，直接向中介租房
            proxy.rent();
        }
    }
    ```

**代理模式的好处：**

- 使真实角色的操作更加纯粹，不用关注一些公共的业务
- 公共交给代理角色，实现业务的分工
- 公共业务拓展的时候，方便集中管理

**代理模式的缺点：**

- 一个真实角色就会产生一个代理角色
- 代码对应`spring-08-proxy/src/main/java/com.iiwowks.demo2`

![image-20201210224037246](https://i.imgur.com/BWGuNay.png)

- 动态代理：动态代理和静态代理角色一样，（代理对象、代理对象、真实对象），**动态代理类是动态生成的**，不是直接写好的。
- 动态代理可以分成两大类： 1. 基于接口的动态代理 2. 基于类的动态代理
  - 基于**接口**：JDK 动态代理
  - 基于**类**：cglib
  - Java 字节码： `javasist`
- 基于接口的动态代理：
  - 需要了解两个类：
  - `Proxy`：代理类
  - `InvocationHandler`：调用处理程序，是由代理实例调用处理程序实现的接口，每个代理实例都有一个关联的调用处理程序，当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的`invoke()`方法
  - `Object invoke(Object proxy, method method, Object[] args) throws Trowable`:处理代理实例上的的方法并返回结果
  - `Proxy`提供了创建动态代理类和实例的静态方法

```java
// 用这个类，自动生成代理类，demo1中的Proxy类是写死了的，
public class ProxyInvocationHandler implements InvocationHandler {

    // 被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    // 生成得到代理类
    public Object getProxy() {
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                    target.getClass().getInterfaces(), this);
    }

    // 处理代理实例，并返回结果
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        // 动态代理的本质，就是使用反射机制实现
        Object result = method.invoke(target, args);
        return result;
    }

    public void log(String msg) {
        System.out.println("执行了" + msg + "方法");
    }
}
```

动态代理的好处：

- 使真实角色的操作更加纯粹，不用关注一些公共的业务
- 公共交给代理角色，实现业务的分工
- 公共业务拓展的时候，方便集中管理
- 一个动态代理类代理的是一个接口，一般就是一类业务
- 一个动态代理类可以代理多个类，只要是实现了同一个接口即可

## 11. AOP

AOP(Aspect Oriented Programming)：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用 AOP 可以对业务逻辑的每个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，提高程序的可重用性，同时提高了开发效率。

### 11.1 AOP 在 Spring 中的作用

- **横切关注点**：跨越应用程序多个模块的方法或功能。即是，与业务逻辑无关的，但是需要我们关注的部分，解释横切关注点。如日志、安全、缓存、事务等等
- **切面（Aspect）**：横切关注点被模块化的特殊对象。即他是一个类
- **通知（Advice）**：切面必须完成的工作。即他是类中的一个方法
- **目标（Target）**：被通知对象
- **代理（Proxy）**：向目标对象应用通知之后创建的对象
- **切入点（PointCut）**：切面通知执行的“地点”的定义
- **连接点（JoinPoint）**：与切入点匹配的执行点

**SpringAOP 中，通过 Advice 定义横切逻辑，Spring 中支持 5 种类型的 Advice：（即 Aop 在不改变原有代码的情况下，去增加新的功能）**

| 通知类型     | 连接点               | 实现接口                                          |
| ------------ | -------------------- | ------------------------------------------------- |
| 前置通知     | 方法前               | `org.springframework.aop.MethodBeforeAdvice`      |
| 后置通知     | 方法后               | `org.springframework.aop.AfterReturningAdvice`    |
| 环绕通知     | 方法前后             | `org.aopalliance.intercept.MethodInterceptor`     |
| 异常抛出通知 | 方法抛出异常         | `org.springframework.aop.ThrowsAdvice`            |
| 引介通知     | 类中增加新的方法属性 | `org.springframework.aop.IntroductionInterceptor` |

### 11.2 使用 Spring 实现 AOP

使用 AOP 织入，需要导入一个依赖包

```java
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.6</version>
    <scope>runtime</scope>
</dependency>
```

- 方法一：使用 Spring 接口

```xml
<!--方式一：使用原生的Spring Api 接口-->
<!-- 注册bean -->
<bean id="userService" class="com.iiwowks.service.UserServiceImpl"/>
<bean id="log" class="com.iiwowks.log.Log"/>
<bean id="afterLog" class="com.iiwowks.log.AfterLog"/>

<!-- 配置aop：需要导入Aop的约束 -->
<aop:config>
    <!-- 切入点 -->
    <!--
        定位到切入点
        expression: 表达式
        execution(要执行的位置)
        修饰词，返回值，列名，方法名，参数
        expression="execution(* com.iiwowks.service.UserServiceImpl.*(..))"
    -->
    <aop:pointcut id="pointcut" expression="execution(* com.iiwowks.service.UserServiceImpl.*(..))"/>
    <!-- 执行环绕增强: 把 log 和 afterLog 这个类切入到这个方法上面 -->
    <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
    <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>
</aop:config>
```

- 方法二：自定义类来实现

```xml
<!-- 方式二：自定义类-->
<bean id="diy" class="com.iiwowks.diy.DiyPointCut"/>
<aop:config>
    <!-- 自定义切面，ref是要引用的类 -->
    <aop:aspect ref="diy">
        <!-- 切入点 -->
        <aop:pointcut id="point" expression="execution(* com.iiwowks.service.UserServiceImpl.*(..))"/>
        <!-- 通知 -->
        <aop:before method="before" pointcut-ref="point"/>
        <aop:after method="after" pointcut-ref="point"/>
    </aop:aspect>
</aop:config>
```

- 方法三：使用注解实现

```java
// 使用注解标注这个类为切面
@Aspect
public class AnnotationPointCut {

    @Before("execution(* com.iiwowks.service.UserServiceImpl.*(..))")
    public void before() {
        System.out.println("*****方法执行前*****");
    }

    @After("execution(* com.iiwowks.service.UserServiceImpl.*(..))")
    public void after() {
        System.out.println("*****方法执行后*****");
    }

    // 在环绕增强中，可以给定一个参数， 代表获取 要处理的切入点
    @Around("execution(* com.iiwowks.service.UserServiceImpl.*(..))")
    public void around(ProceedingJoinPoint jp) throws Throwable {
        System.out.println("--------------环绕前");

        Signature signature = jp.getSignature(); // 获取签名
        System.out.println("签名:" + signature);

        jp.proceed(); // 执行方法
        System.out.println("--------------环绕后");
    }
}
```

```xml
<!-- 方式三 -->
<bean id="annotationPointCut" class="com.iiwowks.diy.AnnotationPointCut"/>
<!-- 开启注解支持 -->
<aop:aspectj-autoproxy/>
```

## 12.整合 mybatis

### 12.1 mybatis 开发流程

步骤：

1. 导入相关 jar 包
   1. `junit`
   2. `mybatis`
   3. `mysql`
   4. `spring`
   5. `aop`织入
   6. `mybatis-spring`

```xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.22</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.6</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.2.9.RELEASE</version>
    </dependency>

    <!-- spring 操作数据库，还需要spring-jdbc -->
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.3.2</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
        <version>1.9.6</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis-spring</artifactId>
        <version>2.0.6</version>
    </dependency>
</dependencies>
```

2. 编写配置文件

3. 测试

`Mybatis`步骤:

1. 编写实体类
2. 编写核心配置文件
3. 编写接口
4. 编写 Mapper.xml
5. 测试

### 12.2 mybatis-spring

本章将会以简略的步骤告诉你如何安装和配置 MyBatis-Spring，并构建一个简单的具备事务管理功能的数据访问应用程序。

#### 安装

要使用 MyBatis-Spring 模块，只需要在类路径下包含 `mybatis-spring-2.0.6.jar` 文件和相关依赖即可。

如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：

```xml
<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis-spring</artifactId>
  <version>2.0.6</version>
</dependency>
```

#### 快速上手

要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 `SqlSessionFactory` 和至少一个数据映射器类。

在 MyBatis-Spring 中，可使用 `SqlSessionFactoryBean`来创建 `SqlSessionFactory`。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：

```xml
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
  <property name="dataSource" ref="dataSource" />
</bean>
```

```java
@Configuration
public class MyBatisConfig {
  @Bean
  public SqlSessionFactory sqlSessionFactory() throws Exception {
    SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
    factoryBean.setDataSource(dataSource());
    return factoryBean.getObject();
  }
}
```

注意：`SqlSessionFactory` 需要一个 `DataSource`（数据源）。这可以是任意的 `DataSource`，只需要和配置其它 Spring 数据库连接一样配置它就可以了。

假设你定义了一个如下的 mapper 接口：

```java
public interface UserMapper {
  @Select("SELECT * FROM users WHERE id = #{userId}")
  User getUser(@Param("userId") String userId);
}
```

那么可以通过 `MapperFactoryBean` 将接口加入到 Spring 中:

```xml
<bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
  <property name="mapperInterface" value="org.mybatis.spring.sample.mapper.UserMapper" />
  <property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>
```

需要注意的是：所指定的映射器类**必须**是一个接口，而不是具体的实现类。在这个示例中，通过注解来指定 SQL 语句，但是也可以使用 MyBatis 映射器的 XML 配置文件。

配置好之后，你就可以像 Spring 中普通的 bean 注入方法那样，将映射器注入到你的业务或服务对象中。`MapperFactoryBean` 将会负责 `SqlSession` 的创建和关闭。 如果使用了 Spring 的事务功能，那么当事务完成时，session 将会被提交或回滚。最终任何异常都会被转换成 Spring 的 `DataAccessException` 异常。

使用 Java 代码来配置的方式如下：

```java
@Configuration
public class MyBatisConfig {
  @Bean
  public UserMapper userMapper() throws Exception {
    SqlSessionTemplate sqlSessionTemplate = new SqlSessionTemplate(sqlSessionFactory());
    return sqlSessionTemplate.getMapper(UserMapper.class);
  }
}
```

要调用 MyBatis 的数据方法，只需一行代码：

```java
public class FooServiceImpl implements FooService {

  private final UserMapper userMapper;

  public FooServiceImpl(UserMapper userMapper) {
    this.userMapper = userMapper;
  }

  public User doSomeBusinessStuff(String userId) {
    return this.userMapper.getUser(userId);
  }
}
```

1. 编写数据源配置
2. sqlSessionFactory
3. sqlSessionTemplate
4. 给接口加实现类
5. 测试

`User.java --> UserMapper.java --> UserMapper.xml --> spring-dao.xml --> UserMapperImpl.java --> applicationContext.xml --> MyTest.java`

## 13.声明式事务

**事务的 ACID 原则：**

1. 原子性
2. 一致性
3. 隔离性（多个业务操作同一个资源，防止数据损坏）
4. 持久性（事务一旦被提交，无论系统发生什么问题，结果不会被改变，被持久化的写入存储器中）

### 13.1 spring 中的事务管理

声明式事务：AOP

编程式事务：需要在代码中，进行事务的管理

## lombok 常用的几个注解

- **@Data** ： 注在类上，提供类的 get、set、equals、hashCode、canEqual、toString 方法
- **@AllArgsConstructor** ： 注在类上，提供类的全参构造
- **@NoArgsConstructor** ： 注在类上，提供类的无参构造
- **@Setter** ： 注在属性上，提供 set 方法
- **@Getter** ： 注在属性上，提供 get 方法
- **@EqualsAndHashCode** ： 注在类上，提供对应的 equals 和 hashCode 方法
- **@Log4j / @Slf4j** ： 注在类上，提供对应的 Logger 对象，变量名为 log
