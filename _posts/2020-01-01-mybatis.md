---
layout: post
title: "mybatis learn"
date: 2020-01-01
category: Backend
author: zhengjunan
published: true
photoswipe: true
syntaxhighlight: true
---

# Mybatis

## 1.简介

Mybatis 是一个优秀的**持久层框架**，支持定制化 sql，存储过程以及高级映射。mybatis 避免了几乎所有的 jdbc 代码和手动设置参数以及获取结果集。mybatis 可以使用简单的 xml 或注解来配置和映射原生类型、接口和 java 的 POJO（普通老式 java 对象）为数据库中的记录。

- maven 仓库
- GIthub
- [mybatis 中文文档](https://mybatis.org/mybatis-3/zh/index.html)
- 数据持久化： 持久化就是将程序的数据在持久状态和瞬时状态转化的过程，使用数据库或者 io 文件来让数据持久化。
- 持久层：**Dao 层**、**Service 层**、**Controller 层**，完成持久化的代码块，层界限十分明显
- 为什么需要 mybatis：1. 方便 2. 传统的 jdbc 代码太复杂，简化，框架名 3. 帮助程序猿将数据存入数据库中
- 特点
  - 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个`jar`文件+配置几个`sql`**映射文件**易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。
  - 灵活：`mybatis`不会对应用程序或者数据库的现有设计强加任何影响。 `sql`写在`xml`里，便于统一管理和优化。通过 sql 语句可以满足操作数据库的所有需求。
  - 解除`sql`与程序代码的耦合：通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。`sql`和代码的分离，提高了可维护性。
  - 提供映射标签，支持对象与数据库的`orm`字段关系映射
  - 提供对象关系映射标签，支持对象关系组建维护
  - 提供`xml`标签，支持编写动态`sql`。

## 2.第一个 mybatis 程序

- 思路：搭建环境 --> 导入 mybatis --> 编写代码 --> 测试
- 搭建数据库

```sql
create database `mybatis`;
use `mybatis`;
create table `user` (
	`id` int(20) not null primary key,
    `name` varchar(30) default null,
    `pwd` varchar(30) default null
)engine=InnoDB default charset=utf8;

insert into `user`(`id`, `name`, `pwd`) values
(1, 'zhengjunan', '123456'),
(2, 'zhangsan', '123456'),
(3, 'lisi', '123456')
```

- 新建项目（新建一个 maven 项目，删除 s r c 目录，导入 maven 依赖，创建 module）
- 创建 module
- 编写 mybatis 的核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!-- 核心配置文件 -->
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8"/>
                <property name="username" value="root"/>
                <property name="password" value="zhengjunan"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 每一个Mapper.xml都需要在Mybatis核心配置文件中注册 -->
    <mappers>
        <mapper resource="com/iiwowks/dao/UserMapper.xml"/>
    </mappers>
</configuration>
```

- 编写`mybatis`工具类

```java
package com.iiwowks.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

// mybatis工具类 sqlSessionFactory -> sqlSession
public class MybatisUtils {
    private static SqlSessionFactory sqlSessionFactory;

    static {
        try{
            // 使用mybatis第一步：获取sqlSessionFactory对象
            String resource = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
```

- 编写代码

  - 实体类

  ```java
  package com.iiwowks.pojo;

  // 实体类
  public class User {
      private int id;
      private String name;
      private String pwd;

      public User() {
      }

      public User(int id, String name, String pwd) {
          this.id = id;
          this.name = name;
          this.pwd = pwd;
      }

      public int getId() {
          return id;
      }

      public void setId(int id) {
          this.id = id;
      }

      public String getName() {
          return name;
      }

      public void setName(String name) {
          this.name = name;
      }

      public String getPwd() {
          return pwd;
      }

      public void setPwd(String pwd) {
          this.pwd = pwd;
      }

      @Override
      public String toString() {
          return "User{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  ", pwd='" + pwd + '\'' +
                  '}';
      }
  }
  ```

  - Dao 接口

  ```java
  package com.iiwowks.dao;

  import com.iiwowks.pojo.User;

  import java.util.List;

  public interface UserDao {
      List<User> getUserList();
  }
  ```

  - 接口实现类：由原来的`UserDaoImpl`转换成`Mapper`配置 文件

  ``` xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

  <!-- namespace = 指定命名空间, 绑定一个指定的Dao/ Mapper接口 -->

  <mapper namespace="com.iiwowks.dao.UserDao">
      <!-- select 查询语句 -->
      <select id="getUserList" resultType="com.iiwowks.pojo.User">
          select * from mybatis.user
      </select>
  </mapper>
  ```

  - 测试：在注册中心中，接口未知

  `org.apache.ibatis.binding.BindingException: Type interface com.iiwowks.dao.UserDao is not known to the MapperRegistry.` 核心配置文件中注册 Mappers.xml

  ```java
  package com.iiwowks.dao;

  import com.iiwowks.pojo.User;
  import com.iiwowks.utils.MybatisUtils;
  import org.apache.ibatis.session.SqlSession;
  import org.junit.Test;

  import java.util.List;

  public class UserDaoTest {

      @Test
      public void test() {
          // 第一步：获取sqlSession对象
          SqlSession sqlSession = MybatisUtils.getSqlSession();
          // 第二步：
          //
          // 方式一：getMapper(UserDao.class)

          UserDao userDao = sqlSession.getMapper(UserDao.class);
          List<User> userList = userDao.getUserList();

          for (User user : userList) {
              System.out.println(user);
          }
          // 第三步：关闭SqlSession
          sqlSession.close();
      }
  }
  ```

  - 可能会遇到的问题：配置文件没有注册、绑定接口错误、方法名不对、返回类型不对、maven 导出资源问题

## 3.CRUD

### 3.1 namespace

- **namespace**中的包名要和**接口 Dao**的包名一致

### 3.2 select

选择，查询语句

- `id`：就是对应的`namespace`中的方法名
- `resultType`：`s q l`语句执行的返回值
- `parameterType`：参数类型

步骤：

1. 编写接口

```java
// 根据id查询用户
User getUserById(int id);
```

2. 编写对应 mapper 中的`s q l`的语句

```xml
<!-- getUserByIt -->
<select id="getUserById" parameterType="int" resultType="com.iiwowks.pojo.User">
    select * from mybatis.user where id = #{id}
</select>
```

3. 测试

```java
@Test
public void getUserById() {
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = userMapper.getUserById(2);
    System.out.println(user);

    sqlSession.commit();
    sqlSession.close();
}
```

### 3.3 insert

### 3.4 update

### 3.5 delete

- 增删改需要提交事务

### 3.6 分析错误

- 标签不要匹配错
- resource 绑定 mapper，需要使用路径
- 程序配置文件必须符合规范
- NullPointerException，没有注册到资源
- 输出的 xml 文件中存在中文乱码问题
- maven 资源没有导出问题

### 3.7 Map

假设实体类，或数据库中的表，字段、参数个数过多，可以考虑使用 Map

- Map 传递参数，直接在 s q l 中取出 key 即可

- 对象传递参数，直接在 s q l 中取出对象的属性即可

- 只传递一个参数的时候，可以直接在 s q l 中取到，不用写`parameterType`

- 传递多个参数的时候，用`Map`或者注解

- 模糊查询使用 通配符 %

  ```java
  List<User> userList = mapper.getUserLike("%li%");
  ```

  ```xml
  select * from mybatis.user where name like "%"#{value}"%"
  ```

## 4.配置解析

### 4.1 核心配置文件

- `mybatis-config.xml`

MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：

- configuration（配置）
  - [properties（属性）](https://mybatis.org/mybatis-3/zh/configuration.html#properties)
  - [settings（设置）](https://mybatis.org/mybatis-3/zh/configuration.html#settings)
  - [typeAliases（类型别名）](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases)
  - [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)
  - [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)
  - [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)
  - [environments（环境配置](https://mybatis.org/mybatis-3/zh/configuration.html#environments)
    - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
  - [databaseIdProvider（数据库厂商标识）](https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider)
  - [mappers（映射器）](https://mybatis.org/mybatis-3/zh/configuration.html#mappers)

### 4.2 环境配置（environments）

MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。

- **不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。**

- 事务管理器 `<transactionManager type="JDBC"/>`
- 数据源 `<dataSource type="POLLED">...</dataSource>`

- Mybatis 默认的任务管理器是 `JDBC`，连接池：`POLLED`

### 4.3 属性（properties）

这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。

- 可以通过`properties`属性来实现引用配置文件
- 在核心配置文件中：`The content of element type "configuration" must match "(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)".`遵循的标签顺序

1. 编写一个配置文件：db.properties

```properties
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&useUnicode=true&characterEncoding=UTF-8
username=root
password=zhengjunan
```

2. 在核心配置文件中引入（内部优先读取，随后被外部覆盖）如果内外有同一个字读，优先使用外部配置文件的字段

```xml
<!-- 引入外部配置文件 -->
<properties resource="db.properties"/>
```

### 4.4 类型别名（typeAliases）

类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。

```xml
<!-- 可以给实体类起别名 -->
<typeAliases>
    <typeAlias alias="User" type="com.iiwowks.pojo.User"/>
</typeAliases>
```

也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean

扫描实体类的包，它的默认别名就是这个类的 首字母小写的类名

```xml
<!-- 可以给实体类起别名 -->
<typeAliases>
    <package name="com.iiwowks.pojo"/>
</typeAliases>
```

- 在实体类较少时，使用第一种方式
- 如果实体类较多，使用第二种方式（扫描包下的实体类，自动取小写开头别名）
- 第一种可以 diy 别名，第二种不行（如果非要改，可以在实体类上添加注解`@Alias()`）

下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。

| 别名       | 映射的类型 |
| :--------- | :--------- |
| \_byte     | byte       |
| \_long     | long       |
| \_short    | short      |
| \_int      | int        |
| \_integer  | int        |
| \_double   | double     |
| \_float    | float      |
| \_boolean  | boolean    |
| string     | String     |
| byte       | Byte       |
| long       | Long       |
| short      | Short      |
| int        | Integer    |
| integer    | Integer    |
| double     | Double     |
| float      | Float      |
| boolean    | Boolean    |
| date       | Date       |
| decimal    | BigDecimal |
| bigdecimal | BigDecimal |
| object     | Object     |
| map        | Map        |
| hashmap    | HashMap    |
| list       | List       |
| arraylist  | ArrayList  |
| collection | Collection |
| iterator   | Iterator   |

### 4.5 设置（settings）

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。

### 4.6 其他配置

- [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)
- [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)
- [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)
  1. Mybatis-generator-core
  2. Mybatis-plus
  3. 通用 mapper

### 4.7 映射器（mappers）

既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。

`MapperRegistry`：注册绑定`Mapper`文件

- 方式一【推荐使用】：使用相对于类路径的资源引用 `<mapper resource="org/mybatis/builder/BlogMapper.xml"/>`
- 方式二： 使用映射器接口实现类的完全限定类名 `<mapper class="org.mybatis.builder.BlogMapper"/>`
  - 接口和他的配置文件必须同名
  - 接口和他的配置文件必须在同一个包下
- 方式三： 将包内的映射器接口实现全部注册为映射器 `<package name="org.mybatis.builder"/>`

### 4.8 生命周期和作用域

错误的使用会导致严重的并发问题

![image-20201215144055276](https://i.imgur.com/cpb1kk0.png)

**SqlSessionFactoryBuilder**

- 一旦创建了 SqlSessionFactory，我们就不需要它了
- 局部变量

**SqlSessionFactory**

- 可以想成作为：**数据库连接池**
- SqlSessionFactory 一旦被创建就应该在应用运行期间一直存在，没有任何理由丢弃或重新创建另一个实例
- SqlSessionFactory 的最佳作用域是应用作用域
- 最简单的就是使用**单例模式**或者**静态单例模式**

**SqlSession**

- 就是连接连接池的一个**请求**
- SqlSession 的实例不是线程安全的，因此不能被共享，所以它的**最佳作用域是请求或方法作用域**
- 用完之后需要赶紧关闭，避免资源被占用

**每一个 Mapper 代表一个具体的业务**

## 5.解决属性名和字段名不一致的问题

```java
// 实体类
public class User {
    private int id;
    private String name;
    private String password;
}
```

- 解决方法一：起别名

```xml
<!-- getUserById -->
<select id="getUserById" parameterType="int" resultType="com.iiwowks.pojo.User">
    select id, name, pwd as password from mybatis.user where id = #{id}
</select>
```

### 5.1 resultMap

结果集映射

```
id  name  pwd
id  name  password
```

```xml
<!-- 结果集映射 -->
<resultMap id="UserMap" type="User">
    <!-- column 是数据库中的字段 -->
    <!-- property 是实体类中的属性 -->
    <result column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="pwd" property="password"/>
</resultMap>
```

- `resultMap` 元素是 MyBatis 中最重要最强大的元素
- ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要**描述语句之间的关系**就行了。

## 6.日志

### 6.1 日志工厂

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。

| 设置名  | 描述                                                  | 有效值                                                                                     | 默认值 |
| :------ | :---------------------------------------------------- | :----------------------------------------------------------------------------------------- | :----- |
| logImpl | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J \| LOG4J \| LOG4J2 \| JDK_LOGGING \| COMMONS_LOGGING \| STDOUT_LOGGING \| NO_LOGGING | 未设置 |

- **STDOUT_LOGGING 标准日志输出**

在核心配置文件中配置日志：

```xml
<!-- 配置日志 -->
<settings>
    <setting name="logImpl" value="STDOUT_LOGGING"/>
</settings>
```

```
Opening JDBC Connection
Created connection 1922930974.
Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@729d991e]
==>  Preparing: select * from mybatis.user where id = ?
==> Parameters: 1(Integer)
<==    Columns: id, name, pwd
<==        Row: 1, zhengjunan, 123456
<==      Total: 1
User{id=1, name='zhengjunan', password='123456'}
Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@729d991e]
Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@729d991e]
Returned connection 1922930974 to pool.
```

- **Log4j**

  - Log4j 是 apache 的一个开源项目，我们可以控制日志信息输送到目的地可以是 **控制台、文件、GUI 组件**

  - 可以控制每一条日志的**输出格式**

  - 通过定义每一条日志信息的级别，可以更加细致的控制日志生成的过程

  - 通过一个**配置文件**进行配置，不需要修改应用代码

  - 步骤：

    - 1. 导入 maven 依赖
    - 2. 创建`log4j.properties`

    ```properties
    #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
    log4j.rootLogger=DEBUG,console,file

    #控制台输出的相关设置
    log4j.appender.console = org.apache.log4j.ConsoleAppender
    log4j.appender.console.Target = System.out
    log4j.appender.console.Threshold=DEBUG
    log4j.appender.console.layout = org.apache.log4j.PatternLayout
    log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

    #文件输出的相关设置
    log4j.appender.file = org.apache.log4j.RollingFileAppender
    log4j.appender.file.File=./log/zhengjunan-log4j-log-test.log
    log4j.appender.file.MaxFileSize=10mb
    log4j.appender.file.Threshold=DEBUG
    log4j.appender.file.layout=org.apache.log4j.PatternLayout
    log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

    #日志输出级别
    log4j.logger.org.mybatis=DEBUG
    log4j.logger.java.sql=DEBUG
    log4j.logger.java.sql.Statement=DEBUG
    log4j.logger.java.sql.ResultSet=DEBUG
    log4j.logger.java.sql.PreparedStatement=DEBUG
    ```

    - 3. 配置 log4j 为日志的实现

    ```xml
    <settings>
        <setting name="logImpl" value="LOG4J"/>
    </settings>
    ```

    ```
    [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection
    [org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 713312506.
    [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2a8448fa]
    [com.iiwowks.dao.UserMapper.getUserById]-==>  Preparing: select * from mybatis.user where id = ?
    [com.iiwowks.dao.UserMapper.getUserById]-==> Parameters: 1(Integer)
    [com.iiwowks.dao.UserMapper.getUserById]-<==      Total: 1
    User{id=1, name='zhengjunan', password='123456'}
    ```

    - 4. 使用：

      导入包 `import org.apache.log4j.Logger;`

      日志对象，参数为当前类的 class ：`static Logger logger = Logger.getLogger(UserMapperTest.class);`

      日志级别：

      ```
      logger.info("info: 进入testLog4j()");
      logger.debug("debug: 进入testLog4j()");
      logger.debug("error: 进入testLog4j()");
      ```

## 7.分页

## 动态 SQL

动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。

使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。

如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。

- if
- choose (when, otherwise)
- trim (where, set)
- foreach

### if

使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：

```
<select id="findActiveBlogWithTitleLike"
     resultType="Blog">
  SELECT * FROM BLOG
  WHERE state = ‘ACTIVE’
  <if test="title != null">
    AND title like #{title}
  </if>
</select>
```

这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。

如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>
```

### choose、when、otherwise

有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。

还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
```

### trim、where、set

前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG
  WHERE
  <if test="state != null">
    state = #{state}
  </if>
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>
```

如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：

```
SELECT * FROM BLOG
WHERE
```

这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:

```
SELECT * FROM BLOG
WHERE
AND title like ‘someTitle’
```

这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。

MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG
  <where>
    <if test="state != null">
         state = #{state}
    </if>
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>
```

_where_ 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，_where_ 元素也会将它们去除。

如果 _where_ 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 _where_ 元素的功能。比如，和 _where_ 元素等价的自定义 trim 元素为：

```
<trim prefix="WHERE" prefixOverrides="AND |OR ">
  ...
</trim>
```

_prefixOverrides_ 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 _prefixOverrides_ 属性中指定的内容，并且插入 _prefix_ 属性中指定的内容。

用于动态更新语句的类似解决方案叫做 _set_。_set_ 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：

```
<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
      <if test="email != null">email=#{email},</if>
      <if test="bio != null">bio=#{bio}</if>
    </set>
  where id=#{id}
</update>
```

这个例子中，_set_ 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。

来看看与 _set_ 元素等价的自定义 _trim_ 元素吧：

```
<trim prefix="SET" suffixOverrides=",">
  ...
</trim>
```

注意，我们覆盖了后缀值设置，并且自定义了前缀值。

### foreach

动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：

```
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
```

_foreach_ 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！

**提示** 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 _foreach_。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。

至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。

### script

要在带注解的映射器接口类中使用动态 SQL，可以使用 _script_ 元素。比如:

```
    @Update({"<script>",
      "update Author",
      "  <set>",
      "    <if test='username != null'>username=#{username},</if>",
      "    <if test='password != null'>password=#{password},</if>",
      "    <if test='email != null'>email=#{email},</if>",
      "    <if test='bio != null'>bio=#{bio}</if>",
      "  </set>",
      "where id=#{id}",
      "</script>"})
    void updateAuthorValues(Author author);
```

### bind

`bind` 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：

```
<select id="selectBlogsLike" resultType="Blog">
  <bind name="pattern" value="'%' + _parameter.getTitle() + '%'" />
  SELECT * FROM BLOG
  WHERE title LIKE #{pattern}
</select>
```

### 多数据库支持

如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “\_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：

```
<insert id="insert">
  <selectKey keyProperty="id" resultType="int" order="BEFORE">
    <if test="_databaseId == 'oracle'">
      select seq_users.nextval from dual
    </if>
    <if test="_databaseId == 'db2'">
      select nextval for seq_users from sysibm.sysdummy1"
    </if>
  </selectKey>
  insert into users values (#{id}, #{name})
</insert>
```

### 动态 SQL 中的插入脚本语言

MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。

可以通过实现以下接口来插入一种语言：

```
public interface LanguageDriver {
  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);
  SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType);
  SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType);
}
```

实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：

```
<typeAliases>
  <typeAlias type="org.sample.MyLanguageDriver" alias="myLanguage"/>
</typeAliases>
<settings>
  <setting name="defaultScriptingLanguage" value="myLanguage"/>
</settings>
```

或者，你也可以使用 `lang` 属性为特定的语句指定语言：

```
<select id="selectBlog" lang="myLanguage">
  SELECT * FROM BLOG
</select>
```

或者，在你的 mapper 接口上添加 `@Lang` 注解：

```
public interface Mapper {
  @Lang(MyLanguageDriver.class)
  @Select("SELECT * FROM BLOG")
  List<Blog> selectBlog();
}
```

**提示** 可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。

你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 `org.apache.ibatis.scripting.xmltags.XmlLanguageDriver`（别名为 `xml`）所提供。
